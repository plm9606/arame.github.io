---
title: jvm 런타임 데이터 영역
categories: [jvm]
tags: [jvm, cs, jvm밑바닥까지파해치기]
author: aram
toc: true
comment: true
---
## 자바 가상 머신 스택
JVM이 자바 프로그램을 실행하는 동안 메서드 호출과 관련된 데이터, 프레임을 관리하는 메모리 구조.

JVM 스택은 스레드 프라이빗 하다.
- 각 스레드마다 독립적인 스택을 가짐
  - 자바 애플리케이션에서 여러 스레드가 동시에 실행될 수 있습니다.
각 스레드는 JVM이 할당한 자체적인 JVM 스택을 가지고 있습니다.
이 스택은 다른 스레드와 공유되지 않습니다. 즉, 하나의 스레드는 다른 스레드의 스택에 접근할 수 없습니다.
- 안전한 동시 실행 (Thread Safety):
  - 여러 스레드가 동시에 실행될 때, 각 스레드가 자신만의 JVM 스택을 가지므로, 스택 내 변수나 데이터에 대한 충돌이 발생하지 않습니다.
이는 동기화 문제를 피하고, 스레드의 독립성을 유지하는 데 중요한 역할을 합니다.
- 독립적인 메서드 호출과 실행 컨텍스트:
  - 각 스레드의 JVM 스택은 메서드 호출 시 생성되는 프레임을 포함합니다.
이 프레임은 메서드의 실행 컨텍스트(지역 변수, 연산 스택 등)를 독립적으로 관리합니다.
따라서, 한 스레드의 메서드 실행이 다른 스레드의 메서드 실행에 영향을 미치지 않습니다.
각 쓰레드마다 별도로 생성되며, 메서드 호출 시 필요한 데이터를 저장하고 관리하는 역할을 합니다.

핫스팟 가상 머신은 가상 머신 스택과 네이티브 메서드 스택을 구분하지 않는다. 

### 스택 프레임
JVM 스택에서 가장 기본적인 단위입니다.
메서드가 호출될 때 마다 jvm은 `스택 프레임`을 만들어서 필요한 정보를 저장하고 스택 프레임을 jvm 스택에 push하고 메서드가 끝나면 pop하는 일을 반복한다.
프레임에는 지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값 등의 정보를 저장한다. 

#### 지역 변수 테이블
지역 변수 테이블은 메서드가 호출될 때 해당 메서드의 모든 지역 변수들을 저장하는 공간이다. 각 메서드 호출마다 생성되는 프레임 내에 위치한다.

저장되는 값
jvm이 컴파일 타임에 알 수 있는 다양한 기본 데이터 타입 *(boolean, byte, char, short, int, long, double, float)*, 객체 참조, 반환 주소 타입을 저장한다. 
지역 변수 테이블의 크기는 컴파일 시점에 결정되며, 메서드마다 고정되어 있다. 이러한 고정 크기는 메모리 관리를 효율적으로 할 수 있게 도와준다.

#### 지역 변수 슬롯

지역 변수 테이블에서 이 데이터 타입들을 저장하는 공간을 **지역 변수 슬롯**이라고 한다. 각 슬롯은 하나의 변수(기본 데이터 타입 또는 객체 참조)에 해당된다. 일반적으로 슬롯 하나의 크기는 32비트이다. double타입 처럼 길이가 64비트인 데이터는 슬롯 두개를 차지하며, 나머지 타입은 모두 슬롯 하나에 저장된다. 

## 자바 힙
자바 힙은 모든 스레드가 공유하며 가상 머신이 구동될 때 만들어진다. 
이 메모리 영역의 목적은 객체 인스턴스를 저장하는 것이다.
자바 힙은 GC가 관리하는 영역이다. 

모든 스레드가 힙을 공유하기 때문에 객체 할당 효율을 높이고자 여러개의 **스레드 로컬 할당 버퍼(TLAB)** 로 나뉜다. 
자바 힙은 모든 스레드가 공유한다. 이때 여러 스레드가 동시에 객체를 생성하고 힙 메모리에 할당하려고 하면, 동기화 문제 및 병목 현상이 발생할 수 있다. 즉, 스레드들이 서로 메모리를 할당받기 위해 경쟁하게 되고, 그 과정에서 성능이 저하될 수 있다.
이런 문제를 해결하기 위해 각 스레드가 힙 메모리에서 일정 크기만큼의 고정된 메모리 영역을 미리 할당받는데 그게 바로 TLAB이다. 스레드는 객체를 생성할 때, 먼저 자신에게 할당된 TLAB 내에서 메모리 할당을 시도하고 이 과정에서 다른 스레드와의 동기화 필요없이 메모리를 할당받을 수 있어 매우 빠르게 처리가 가능해지는 것이다.
=> 메모리 회수와 할당을 더 빠르게 하기 위함이다.

자바 힙은 물리적으로 떨어진 메모리에 위치해도 상관 없으나 논리적으로는 연속되어야 한다. 

| **특징**                | **JVM 스택**                                            | **힙(Heap)**                                               |
|-------------------------|---------------------------------------------------------|------------------------------------------------------------|
| **메모리 영역**         | 각 스레드마다 독립적으로 생성                           | 모든 스레드가 공유                                          |
| **저장 내용**           | 메서드의 지역 변수, 매개변수, 리턴 주소                 | new 키워드로 생성된 객체(인스턴스, 배열 등)                 |
| **생명 주기**           | 메서드 실행 중에만 존재                                  | 객체가 더 이상 참조되지 않을 때까지                        |
| **접근 속도**           | 매우 빠름                                               | 상대적으로 느림                                            |
| **메모리 관리**         | 메서드 호출 시 자동으로 생성 및 제거                    | 가비지 컬렉션에 의해 관리                                   |
| **주 용도**             | 메서드 호출 시 필요한 임시 저장 공간                    | 객체 인스턴스와 배열의 저장 공간                            |
| **데이터 타입**         | 기본 데이터 타입과 객체 참조 타입                       | 객체 인스턴스와 배열 전체                                   |
| **주요 예외**           | StackOverflowError: 스택이 가득 찰 때                   | OutOfMemoryError: 힙 메모리가 부족할 때                    |
| **안전성**              | 스레드 프라이빗: 다른 스레드와 독립적                   | 여러 스레드가 접근하므로 동기화 문제 가능                    |


# 핫스팟 자바 힙에서 객체
## 객체 생성 과정
- jvm이 new명령에 해당하는 바이트코드 읽음
- 이 명령의 매개변수가 상수 풀 안의 클래스를 가르키는 심벌인지 확인
- 심벌 참조가 뜻하는 클래스가 로딩, resolve, 초기화 되었는지 확인
- 자바 힙에 새 객체를 담을 메모리 할당
    - r가용 공간 어떻게 나눌건지
        - 포인터 밀치기
        - free list
    - 동시에 여러 객체 생성 요청이 들어올 때
        - 메모리 할당을 동기화
        - 스레드마다 다른 메모리 공간 할당(스레드 로컬 할당 버퍼/TLAB)
- 각 객체에 필요한 설정과 기본 정보들을 객체 헤더에 저장
--- 머신 관점에서 객체 생성 끝 ---

## 객체 메모리 레이아웃
객체를 세 부분으로 나눠 힙에 저장
- 객체 헤더
- 인스턴트 데이터
    - 객체가 실제로 담고 있는 정보
- alignment padding


## 객체에 접근하기
- 핸들
- 포인터
