---
title: 가비지 컬렉터와 메모리 할당 전략
categories: [jvm]
tags: [jvm, cs, jvm밑바닥까지파해치기, gc, memory]
author: aram
toc: true
comment: true
---
**gc를 알아야하는 이유**

다양한 메모리 오버플로와 누수 문제를 해결해야 하는 상황이나 더 높은 동시성을 달성하는 데 gc가 방해되는 상황이 오면, 이 자동화된 기술을 적절히 모니터링하고 조율할 수 있어야 함.


가비지 컬렉터
- 무엇을
    - 죽은 대상을
        - 죽은 대상을 확인하는 방법
            - 도달 가능성 분석 알고리즘
- 언제 
- 어떻게

회수할 것인가?

## 죽은 대상을 확인하는 방법
어떤 것이 죽은 대상? -> 더이상 참조가 없는 객체들

### 참조의 종류
1. 강한 참조
2. 부드러운 참조
3. 약한 참조
4. 유령 참조
5. 파이널 참조

> finalize를 써가면서 까지 지켜야하는 케이스 뭐가 있을까
> 오 근데 JDK 9 버전에서 dprecated되었다고 함. https://olrlobt.tistory.com/76

### 도달 가능성 분석 알고리즘
GC 루트라고 하는 루트 객체들을 시작 노드 집합으로 쓰는 것이다. 
어떤 것이 죽은 대상? -> gc루트에서 도달할 수 없는 노드 집합

> 👇 왜 얘네가 루트로 쓰이게 되었는지 궁금


GC루트로 이용할 수 있는 객체
- 가상 머신 스택에서 참조하는 객체
- 메서드 영역에서 클래스가 정적 필드로 참조하는 객체
- 메서드 영역에서 상수로 참조되는 객체
- 네이티브 메서드 스택에서 JNI가 참조하는 객체
- 자바 가상 머신 내부에서 쓰이는 참조


메서드 영역 회수하기
gc -> 힙만 청소하는거 아님. 다른데도 회수 대상 가능함. 다만 힙 메모리보다 회수 로직이복잡하고 효율이 안나서 GC별로 선택적으로 회수
메서드 영역의 가비지 컬렉션은 크게 두 가지를 회수한다. 더이상 사용되지 않는 상수와 클래스
- 더 이상 쓰이지 않는 클래스 판단하는 조건 (까다로움)
    - 이 클래스의 인스턴스가 모두 회수되었다.
    - 이 클래스를 읽어들인 클래스 로더가 회수되었다. 
    - 이 클래스에 해당하는 java.lang.Class 객체를 아무 곳에서도 참조하지 않고, 리플렉션 기능으로 이 클래스의 메서드를 이용하는 곳도 전혀 없다.

> ❓ java.lang.Class는 무엇? 이게 뭐길래?


## 가비지 컬렉션 알고리즘
### 세대 단위 컬렉션 이론
가설
1. 약한 새대 가설: 대다수 객체는 일찍 죽는다
2. 강한 세대 가설: 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 . 더오래 살 가능성이 커진다
3. 세대 간 참조 가설: 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다

이 가설을 기반으로 자바 힙을 구성한다. (회수의 효율화를 위해)
대부분의 객체는 죽을 운명이니 곧 회수 될 객체에 정보를 표시하기 보다 오래 살아남은 객체를 따로 관리하는 것이 효율적.
오래 살아남은 객체들은 영역을 따로 나누어 관리한다. -> 가비지 컬렉터는 한번에 하나 또는 몇개 영역만 선택해 회수가 가능해짐. 영역에 담긴 객체들의 생존 특성에 따라 가비지 컬렉터의 알고리즘도 다르게 선택해 적용할 . 수있음

세대간 참조의 수는 아주 적기 때문에 구세대 전체를 훑는ㄴ건 낭비다. 
신세대에 기억 집합이라는 전역 데이터 구조를 하나 두면 된다. 이. ㅜ조를 통해 구세대를 작은 조각 몇 개로 나누고, 그중 어즈 조각에 세대 간 참조가 있는지 기록해 관리하는 것이다. 
런타임에 할 일이 늘어나지만 구세대 전체를 훑는 비용보다는 여전히 싸다

> 매번 객체 지울 때 마다 세대 간 참조가 있는지 구세대를 훑는게 아니라 미리 구세대와 연결되어있는 신세대 객체 정보 같은걸 공동으로 저장해두고 관리한다는건가?

> ❓ gc루트와 세대별 격리는 어떻게 구성되어있는건지. 세대별로 루트 아니면 루트는 세대 상관없이 전역적으로

## HOW
### 마크-스윕 알고리즘
회수 할 객체를 mark, 그리고 쓸어담기
단점
1. 실행 효율이 일정하지 않다. 객체가 많아질수록 표시하고 쓸어담는 작업의 효율이 떨어진다.
2. 메모리 파편화가 심하다

### 마크-카피 알고리즘
가용 메모리를 똑같은 크기의 두 블록으로 나눠서 한번에 한 블록만 사용. mark하고 다른 영역 메모리로 카피해서 파편화 해소. 
가용메모리가 절반으로 줄어드는 것이 단점

오늘날 상용 jvm 대부분은 신세대에 이 알고리즘 활용.
아펠 스타일 컬렉션 방식으로. 신세대를 하나의 큰 에덴공간과 두개의 작은 생존자 공간으로 나누고 메모리 할당할 때는 생존자 공간 중 하나와 에덴만 사용. 

### 마크 - 컴펙트 알고리즘
마크 - 회수 - 회수 후 컴펙트를 통한 파편화 방지
메모리 이동이 일어나는것이 큰 차이. -> 이 때 사용자 애플리케이션을 전부 멈춘채 해야해서 치명적임


## 핫스팟 알고리즘 상세 구현
### 루트 노드 열거
= gc루트 집합으로부터 참조 체인을 찾는 작업.
루트 노드를 열거하려면 스탑더 월드가 필연적임. 
하지만 현재 주류 자바 가상 머신들은 '정확한 가비지 컬렉션'을 사용한다. 따라서 사용자 스레드가 정지한 후 실행 콘텍스트와 전역 참조의 위치를 빠짐없이 확인할 필요가 없다. 그 대신 가상머신이 객체 참조가 저장된 위치를 직접 알아낼 방법이 있어야 한다. 

> 정확하게 이해하지 못함..


> 가비지 컬렉션(Garbage Collection)과 객체 참조
자바에서는 개발자가 직접 메모리를 관리하지 않아도 되는데, 가비지 컬렉션이 이를 대신해 줍니다. 가비지 컬렉션은 더 이상 사용되지 않는 객체(즉, 어떤 변수나 다른 객체도 참조하지 않는 객체)를 자동으로 제거함으로써 메모리 누수를 방지합니다.
>
>정확한 가비지 컬렉션(Precise Garbage Collection) vs 부정확한 가비지 컬렉션(Conservative Garbage Collection)
정확한 가비지 컬렉션(Precise Garbage Collection): JVM이 어떤 메모리 위치가 객체에 대한 참조인지 정확하게 알고 있어서, 올바른 객체만을 가비지 컬렉션의 대상으로 삼을 수 있습니다. 다시 말해, JVM은 객체 참조가 저장된 위치를 정확히 파악하고 있습니다.
>
>부정확한 가비지 컬렉션(Conservative Garbage Collection): 시스템이 어떤 메모리 위치가 객체 참조인지 확실하게 알지 못하므로, 메모리의 내용이 객체에 대한 주소인지 아닌지를 유추해야 하는 방식입니다. 이 방식은 잠재적으로 객체가 아닌 데이터를 잘못 식별할 위험이 있습니다.

정확한 가비지 컬렉션을 사용한다: 주류 자바 가상 머신들은 정확한 가비지 컬렉션을 사용하고 있기 때문에, JVM은 객체 참조가 정확히 저장된 위치를 알고 있습니다.

실행 콘텍스트와 전역 참조의 위치를 빠짐없이 확인할 필요가 없다: 정확한 가비지 컬렉션 덕분에, JVM은 각 객체 참조가 어디에 저장되어 있는지 이미 알고 있어, 모든 실행 콘텍스트와 전역 참조의 위치를 별도로 추적할 필요가 없습니다. 이는 코드의 효율성을 높여줍니다.

가상머신이 객체 참조가 저장된 위치를 직접 알아낼 방법: **대신에, JVM은 스스로 객체 참조가 저장된 위치를 정확히 파악하고 있어야 합니다.** 이는 JVM이 정확한 메모리 관리와 효율적인 가비지 컬렉션을 수행할 수 있도록 도와줍니다.

핫스팟은 `OopMap`이라는 데이터 구조를 이용해 이 문제를 해결

### 안전 지점
OopMap을 통해서 GC루트를 알 수 있지만 모든 명령어에 OopMap을 만들면 메모리 낭비가 심함.
-> 그래서 모든 명령어에 OopMap을 생성하지 않고 안전 지점(safe point)라고 하는 특정 위치에만 OopMap을 기록한다. 

가비지 컬렉터는 사용자 프로그램이 안전 지점에 도달하기 전 까지 절대 멈춰세우지 않는다. 

- 안전지점을 그럼 어디에 심어두어야 할까?
  -프로그램이 장시간 실행될 가능성이 있는 곳에. == 명령어 흐름이 다중화 될 때
  -ex. 메서드 호출, 순환문, 예외처리 등
- 어떻게 안전 지점까지 멈추지 않고 실행하게 하고 멈추게 할까?
    - 선제적 멈춤
    - 자발적 멈춤

### 안전 지역
안전 지점은 실행중인 프로그램이 그리 길지 않은 시간에 안전 지점에 도달해 가비지 컬렉션 프로세스가 제대로 임무를 다할 수 있게끔 보장한다. 
하지만 실행중이 `아닌` 프로그램이라면?
- 이 상태의 스레드들은 가상머신의 인터셉터 요청에 응답 불가
- 안전 지점까지 수행한 후 인터럽트 되어 스스로를 일시정지 시킬 수 없다. 
- 이 스레드가 다시 활성화 되어 안전 지점 올때 까지도 기다릴 수 없음

그래서 안전 지역이 탄생

안전지역은 일정 코드 영역에서는 참조 관계가 변하지 않음을 보장한다. 
안전 지역 안이라면 어디서든 가비지 컬렉션을 시작해도 무방하다는 것.

사용자 스레드는 안전지역에 진입했음을 표시한다. 그리고 안전 지역을 벗어날 때는 가상 머신이 루트 노드 완료했는지 등등 확인 절차를 거쳐야해서 안전하게 벗어날 수 있다. 

### 기억 집합과 카드 테이블
가비지 컬렉터는 신세대에 기억 집합이라는 데이터 구조를 두어 객체들의 세대 간 참조 문제를 해결한다고 했다. 
#### 기억 집합
기억 집합은 비회수 영역에서 회수 영역을 가리키는 포인터들을 기록하는 추상데이터 구조.
기억 집합을 이용해 GC루트의 스캔 범위를 줄이는 문제 해결

카드 정밀도로 기억 집합을 구현한 것을 카드 테이블. 현재 가장 널리 쓰이는 방식임

### 쓰기 장벽
카드 테이블에 더럽혀졌다는 표시를 어떻게 할 것인가?
객체가 대입되는 순간 해당 카드 테이블을 어떻게 갱신하느냐?
=> 참조 타입에 객체가 대입되기 전 후로 추가 동작을 수행할 수 있도록 한다. (aop처럼..) 
참조 타입 대입 전/후에 장벽이 카드 테이블 상태를 갱신한다. 

> ❓ 대입 후에 갱신 전에 에러 등이 발생되어서 실행 안되면 어떻게 되는거지?
