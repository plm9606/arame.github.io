---
title: 비관적 락/낙관적 락
categories: [database]
tags: [lock, cs, database]
author: aram
toc: true
comment: true
---
# 비관적 락 / 낙관적 락

낙관적 락(Optimistic Lock)과 비관적 락(Pessimistic Lock)은 싱글 DB 환경인 경우에만 적용 가능한 개념이다. 샤딩 또는 Replication 등을 통해 DB가 분산되어있는 환경이라면 적용할 수 없다.
분산 락(distributed Lock)

## DB 충돌을 개선할 수 있는 방법
database에 접근해서 데이터를 수정할 때 동시에 수정이 일어나 충돌이 일어날 수 있습니다. 우리는 이런 상황을 해결할 수 있도록 코딩을 진행해야합니다. 어떻게 해결할 수 있을까요 ?

첫번째, 테이블의 row에 접근시 Lock을 걸고 다른 Lock이 걸려 있지 않을 경우에만 수정을 가능하게 할 수 있습니다.

두번째, 수정할 때 내가 먼저 이 값을 수정했다고 명시하여 다른 사람이 동일한 조건으로 값을 수정할 수 없게 하는 것입니다.

## 낙관적 락 (Optimistic Lock)
대부분의 트랜잭션이 충돌이 발생하지 않을 것이라고 낙관적으로 가정하는 방법이다. 따라서 데이터베이스가 제공하는 락 기능을 사용하지 않고, 엔티티의 버전을 통해 동시성을 제어한다. 즉, 어플리케이션 레벨에서 지원하는 락이다.

## 비관적 락
이 기법은 데이터의 충돌이 자주 발생한다고 가정하고, 데이터를 조회하는 시점에서부터 데이터가 수정되는 시점까지 락을 걸어 다른 트랜잭션이 해당 데이터에 접근하지 못하게 막는다.
비관적 락은 실제로 데이터베이스의 락을 사용하여 동시성을 제어하는 방법이다. 주로 쿼리에 SELECT ... FOR UPDATE 구문을 사용하고, 버전 정보는 사용하지 않는다. 락을 직접 걸기 때문에 아래의 두 가지 특징이 있다.
엔티티가 아닌 스칼라 타입을 조회할 때도 사용할 수 있다.
데이터를 수정하는 즉시 트랜잭션의 충돌을 감지할 수 있다.

트랜잭션이 시작될 때 shared lock또는 exclusive lock을 걸고 시작한다.
### shared lock?
Read Lock이라고도 불리는 공유락은 트랜잭션이 읽기를 할 때 사용하는 락이며, 데이터를 읽기만하기 때문에 같은 공유락끼리는 동시에 접근이 가능하지만, write 작업은 막는다.
### exclusive lock?
Write Lock이라고도 불리며, 데이터를 변경할 때 사용하는 락이다. 트랜잭션이 완료될 때까지 유지되며, 배타락이 끝나기 전까지 read/write를 모두 막는다.


비관적 락은 Repeatable Read 또는 Serializable 정도의 격리성 수준을 제공한다.


> Repeatable Read
> 트랜잭션이 시작된 후에는 같은 데이터를 반복해서 읽어도 항상 같은 값을 얻을 수 있음.
> Dirty Read와 Non-repeatable Read는 방지하지만, Phantoms는 발생할 수 있음.
> Serializable
> 가장 높은 격리성 수준으로, 트랜잭션을 직렬화하는 것처럼 동작하게 만듬.
> 시스템이 여러 트랜잭션을 동시에 실행할 때에도 마치 트랜잭션들이 순차적으로 순서대로 실행된 것처럼 보이도록 한다는 의미. 실제로는 여러 트랜잭션이 동시에 실행되지만, 시스템은 그들 간의 충돌을 관리하고 조정하여 결과적으로 모든 트랜잭션이 독립적으로 실행된 것과 같은 효과를 제공.
> 
> > 직렬화? Serialization
> > 트랜잭션을 순차적으로 하나씩 실행하는 것을 의미. 트랜잭션 A가 끝난 후에야 트랜잭션 B가 시작되는 방식으로 두 트랜잭션 간의 충돌이 전혀 발생하지 않음
> > 성능이 크게 저하되는 단점
> > 
> 
> Dirty Read, Non-repeatable Read, Phantoms 모두 방지
> 
> >Dirty Read: 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 문제.
> Non-repeatable Read: 같은 트랜잭션 내에서 같은 데이터를 반복해서 읽을 때 값이 달라지는 문제.
> Phantom Read: 트랜잭션 내에서 한번 데이터를 읽은 후, 같은 조건으로 데이터를 다시 읽을 때 새로운 행이 추가되어 있는 문제.
> 
> 이 격리성 수준에서는 하나의 트랜잭션이 종료되기 전에는 다른 트랜잭션이 같은 데이터에 접근할 수 없음

=> 데이터에 락을 걸어 다른 트랜잭션이 해당 데이터에 접근하지 못하게 막아, 트랜잭션이 완료될 때까지 기다리게 해서 자연스럽게 직렬화된 실행 방식을 구현


#### 장점
- 안전성: 데이터의 일관성과 무결성을 확실하게 보장해준다는 점에서 매우 안전
- 충돌 방지: 충돌 가능성이 높은 경우 데이터의 정합성을 유지
#### 단점
성능 저하: 락이 걸린 데이터에 대해 다른 트랜잭션이 대기해야 하기 때문에 성능이 저하될 수 있음
교착 상태(Deadlock): 여러 트랜잭션이 서로 락을 걸어 교착 상태가 발생할 가능성이 높음

#### 단점 어떻게 해결할까?
- Redis Sorted Set 활용
- Redis의 Lua Script 활용
- Kafka와 같은 메시징 큐 도입
- API Gateway에서 처리율 제한 알고리즘 구현
- 처리율 제한기 미들웨어 도입

> appendix.
> https://www.youtube.com/watch?v=MTSn93rNPPE&t=710s
> API Gateway, 처리율 제한기 미들웨어와 관한 내용은 ”가상 면접 사례로 배우는 대규모 시스템 설계 기초” 책



## Tradeoff
낙관적락과 비관적락을 사용하는 기준은 "동시에 수정을 하는일이 빈번하게 일어나는가 ?" 

비관적 락을 사용하면 좋은 경우
데이터의 무결성이 중요하다.
데이터 충돌이 많이 발생할 것으로 예상된다.


낙관적 락을 사용하면 좋은 경우
데이터 충돌이 자주 일어나지 않을 것이라고 예상된다.
조회 작업이 많아 동시 접근 성능이 중요하다.


## 두 번의 갱신 분실 문제 (second lost updates problem)
데이터베이스 트랜잭션에서 발생할 수 있는 동시성 문제로, 두 번째 트랜잭션의 업데이트가 첫 번째 트랜잭션의 커밋에 의해 손실되는 상황. 

3가지의 처리방법이 존재한다.
- 마지막 커밋만 인정하기: 유저1의 변경 내용을 무시하고, 마지막에 커밋한 유저2의 내용만을 반영한다.
- 최초 커밋만 인정하기: 유저1이 수정을 완료했으므로, 유저2의 변경 사항에 대해 오류를 발생시킨다.
- 충돌하는 내용 병합하기: 유저1과 유저2의 변경 사항을 병합한다.

해결 방법
1. 트랜잭션 격리 수준 조정
마지막 커밋만 인정하기 방법 외에 정책을 구현할 수 없음.

2. 락 메커니즘 사용
비관적 락 - 최초 커밋만 인정하기
병합은 주로 낙관적 락(Optimistic Lock) 시나리오나 애플리케이션 레벨에서 관리되는 병합 전략에서 더 자주 사용

3. 애플리케이션 레벨에서의 동시성 관리:
애플리케이션 레벨에서 동시성 제어난 제대로 처리하기 위해 동기화(synchronization) 메커니즘이나 분산 락 등을 사용할 수 있음


## ref
https://sabarada.tistory.com/175
https://velog.io/@znftm97/동시성-문제-해결하기-V2-비관적-락Pessimistic-Lock
https://hudi.blog/jpa-concurrency-control-optimistic-lock-and-pessimistic-lock/
